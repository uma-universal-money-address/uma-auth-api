// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * UMA Auth API
 *
 * This API allows you to authenticate with the UMA server to take actions on a user's wallet. It's the exposed communication layer between the NWC server and the main UMA server.
 *
 * API version: 0.1
 */

package umaauth

import (
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

// UmaAuthAPIController binds http requests to an api service and writes the service results to the http response
type UmaAuthAPIController struct {
	service UmaAuthAPIServicer
	errorHandler ErrorHandler
}

// UmaAuthAPIOption for how the controller is set up.
type UmaAuthAPIOption func(*UmaAuthAPIController)

// WithUmaAuthAPIErrorHandler inject ErrorHandler into controller
func WithUmaAuthAPIErrorHandler(h ErrorHandler) UmaAuthAPIOption {
	return func(c *UmaAuthAPIController) {
		c.errorHandler = h
	}
}

// NewUmaAuthAPIController creates a default api controller
func NewUmaAuthAPIController(s UmaAuthAPIServicer, opts ...UmaAuthAPIOption) *UmaAuthAPIController {
	controller := &UmaAuthAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the UmaAuthAPIController
func (c *UmaAuthAPIController) Routes() Routes {
	return Routes{
		"ExecuteQuote": Route{
			strings.ToUpper("Post"),
			"/umanwc/v1/quote/{payment_hash}",
			c.ExecuteQuote,
		},
		"FetchQuoteForLud16": Route{
			strings.ToUpper("Get"),
			"/umanwc/v1/quote/lud16",
			c.FetchQuoteForLud16,
		},
		"GetBalance": Route{
			strings.ToUpper("Get"),
			"/umanwc/v1/balance",
			c.GetBalance,
		},
		"GetBudgetEstimate": Route{
			strings.ToUpper("Get"),
			"/umanwc/v1/budget_estimate",
			c.GetBudgetEstimate,
		},
		"GetInfo": Route{
			strings.ToUpper("Get"),
			"/umanwc/v1/info",
			c.GetInfo,
		},
		"ListTransactions": Route{
			strings.ToUpper("Get"),
			"/umanwc/v1/transactions",
			c.ListTransactions,
		},
		"LookupInvoice": Route{
			strings.ToUpper("Get"),
			"/umanwc/v1/invoices/{payment_hash}",
			c.LookupInvoice,
		},
		"LookupUserByLud16": Route{
			strings.ToUpper("Get"),
			"/umanwc/v1/receiver/lud16/{receiver_address}",
			c.LookupUserByLud16,
		},
		"MakeInvoice": Route{
			strings.ToUpper("Post"),
			"/umanwc/v1/invoice",
			c.MakeInvoice,
		},
		"PayInvoice": Route{
			strings.ToUpper("Post"),
			"/umanwc/v1/payments/bolt11",
			c.PayInvoice,
		},
		"PayKeysend": Route{
			strings.ToUpper("Post"),
			"/umanwc/v1/payments/keysend",
			c.PayKeysend,
		},
		"PayToLud16Address": Route{
			strings.ToUpper("Post"),
			"/umanwc/v1/payments/lud16",
			c.PayToLud16Address,
		},
	}
}

// ExecuteQuote - execute_quote: Execute a quote
func (c *UmaAuthAPIController) ExecuteQuote(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	paymentHashParam := params["payment_hash"]
	if paymentHashParam == "" {
		c.errorHandler(w, r, &RequiredError{"payment_hash"}, nil)
		return
	}
	executeQuoteRequestParam := ExecuteQuoteRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&executeQuoteRequestParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertExecuteQuoteRequestRequired(executeQuoteRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertExecuteQuoteRequestConstraints(executeQuoteRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.ExecuteQuote(r.Context(), paymentHashParam, executeQuoteRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// FetchQuoteForLud16 - fetch_quote_for_lud16: Get a quote for a payment to an LUD16 address
func (c *UmaAuthAPIController) FetchQuoteForLud16(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var sendingCurrencyCodeParam string
	if query.Has("sending_currency_code") {
		param := query.Get("sending_currency_code")

		sendingCurrencyCodeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "sending_currency_code"}, nil)
		return
	}
	var receivingCurrencyCodeParam string
	if query.Has("receiving_currency_code") {
		param := query.Get("receiving_currency_code")

		receivingCurrencyCodeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "receiving_currency_code"}, nil)
		return
	}
	var lockedCurrencyAmountParam int64
	if query.Has("locked_currency_amount") {
		param, err := parseNumericParameter[int64](
			query.Get("locked_currency_amount"),
			WithParse[int64](parseInt64),
			WithMinimum[int64](0),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "locked_currency_amount", Err: err}, nil)
			return
		}

		lockedCurrencyAmountParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "locked_currency_amount"}, nil)
		return
	}
	var lockedCurrencySideParam LockedCurrencySide
	if query.Has("locked_currency_side") {
		param := LockedCurrencySide(query.Get("locked_currency_side"))

		lockedCurrencySideParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "locked_currency_side"}, nil)
		return
	}
	var receiverAddressParam string
	if query.Has("receiver_address") {
		param := query.Get("receiver_address")

		receiverAddressParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "receiver_address"}, nil)
		return
	}
	result, err := c.service.FetchQuoteForLud16(r.Context(), sendingCurrencyCodeParam, receivingCurrencyCodeParam, lockedCurrencyAmountParam, lockedCurrencySideParam, receiverAddressParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetBalance - get_balance: Get the balance of the user's wallet
func (c *UmaAuthAPIController) GetBalance(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var currencyCodeParam string
	if query.Has("currency_code") {
		param := query.Get("currency_code")

		currencyCodeParam = param
	} else {
	}
	result, err := c.service.GetBalance(r.Context(), currencyCodeParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetBudgetEstimate - get_budget_estimate: Estimate the total cost of the payment to complete the payment in the currency of sender's budget.
func (c *UmaAuthAPIController) GetBudgetEstimate(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var sendingCurrencyCodeParam string
	if query.Has("sending_currency_code") {
		param := query.Get("sending_currency_code")

		sendingCurrencyCodeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "sending_currency_code"}, nil)
		return
	}
	var sendingCurrencyAmountParam int64
	if query.Has("sending_currency_amount") {
		param, err := parseNumericParameter[int64](
			query.Get("sending_currency_amount"),
			WithParse[int64](parseInt64),
			WithMinimum[int64](0),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "sending_currency_amount", Err: err}, nil)
			return
		}

		sendingCurrencyAmountParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "sending_currency_amount"}, nil)
		return
	}
	var budgetCurrencyCodeParam string
	if query.Has("budget_currency_code") {
		param := query.Get("budget_currency_code")

		budgetCurrencyCodeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "budget_currency_code"}, nil)
		return
	}
	result, err := c.service.GetBudgetEstimate(r.Context(), sendingCurrencyCodeParam, sendingCurrencyAmountParam, budgetCurrencyCodeParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetInfo - get_info: Get information about the user's wallet connection
func (c *UmaAuthAPIController) GetInfo(w http.ResponseWriter, r *http.Request) {
	result, err := c.service.GetInfo(r.Context())
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// ListTransactions - list_transactions: Lists invoices and payments
func (c *UmaAuthAPIController) ListTransactions(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var fromParam int64
	if query.Has("from") {
		param, err := parseNumericParameter[int64](
			query.Get("from"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "from", Err: err}, nil)
			return
		}

		fromParam = param
	} else {
	}
	var untilParam int64
	if query.Has("until") {
		param, err := parseNumericParameter[int64](
			query.Get("until"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "until", Err: err}, nil)
			return
		}

		untilParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](0),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](0),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "offset", Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	var unpaidParam bool
	if query.Has("unpaid") {
		param, err := parseBoolParameter(
			query.Get("unpaid"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "unpaid", Err: err}, nil)
			return
		}

		unpaidParam = param
	} else {
	}
	var type_Param TransactionType
	if query.Has("type") {
		param := TransactionType(query.Get("type"))

		type_Param = param
	} else {
	}
	result, err := c.service.ListTransactions(r.Context(), fromParam, untilParam, limitParam, offsetParam, unpaidParam, type_Param)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// LookupInvoice - lookup_invoice: Get an invoice by its payment hash
func (c *UmaAuthAPIController) LookupInvoice(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	paymentHashParam := params["payment_hash"]
	if paymentHashParam == "" {
		c.errorHandler(w, r, &RequiredError{"payment_hash"}, nil)
		return
	}
	result, err := c.service.LookupInvoice(r.Context(), paymentHashParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// LookupUserByLud16 - lookup_user_by_lud16: Get receiver info by LUD16 address.
func (c *UmaAuthAPIController) LookupUserByLud16(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	receiverAddressParam := params["receiver_address"]
	if receiverAddressParam == "" {
		c.errorHandler(w, r, &RequiredError{"receiver_address"}, nil)
		return
	}
	var baseSendingCurrencyCodeParam string
	if query.Has("base_sending_currency_code") {
		param := query.Get("base_sending_currency_code")

		baseSendingCurrencyCodeParam = param
	} else {
	}
	result, err := c.service.LookupUserByLud16(r.Context(), receiverAddressParam, baseSendingCurrencyCodeParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// MakeInvoice - make_invoice: Create a new invoice
func (c *UmaAuthAPIController) MakeInvoice(w http.ResponseWriter, r *http.Request) {
	makeInvoiceRequestParam := MakeInvoiceRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&makeInvoiceRequestParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertMakeInvoiceRequestRequired(makeInvoiceRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertMakeInvoiceRequestConstraints(makeInvoiceRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.MakeInvoice(r.Context(), makeInvoiceRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PayInvoice - pay_invoice: Pay a bolt11 invoice
func (c *UmaAuthAPIController) PayInvoice(w http.ResponseWriter, r *http.Request) {
	payInvoiceRequestParam := PayInvoiceRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&payInvoiceRequestParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertPayInvoiceRequestRequired(payInvoiceRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertPayInvoiceRequestConstraints(payInvoiceRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.PayInvoice(r.Context(), payInvoiceRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PayKeysend - pay_keysend: Pay directly to the pubkey of the receiver node based on a fixed receiving amount
func (c *UmaAuthAPIController) PayKeysend(w http.ResponseWriter, r *http.Request) {
	payKeysendRequestParam := PayKeysendRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&payKeysendRequestParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertPayKeysendRequestRequired(payKeysendRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertPayKeysendRequestConstraints(payKeysendRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.PayKeysend(r.Context(), payKeysendRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PayToLud16Address - pay_to_lud16_address: Pay directly to an LNURL address based on a fixed sending amount.
func (c *UmaAuthAPIController) PayToLud16Address(w http.ResponseWriter, r *http.Request) {
	payToAddressRequestParam := PayToAddressRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&payToAddressRequestParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertPayToAddressRequestRequired(payToAddressRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertPayToAddressRequestConstraints(payToAddressRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.PayToLud16Address(r.Context(), payToAddressRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}
